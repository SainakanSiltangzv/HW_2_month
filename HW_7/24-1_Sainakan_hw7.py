#ДЗ*:
#1. Написать функцию binary_search, принимающую в качестве входящего параметра элемент для поиска и список
# котором необходимо искать.
#2. Алгоритм должен искать с помощью двоичного поиска, изображенного на блок-схеме презентации.
#3. Функция в итоге должна распечатать результат. Применить 1 раз эту функцию
#4. Написать функцию buble_sort или selection_sort, принимающую в качестве входящего параметра не отсортированный список.
#5. Алгоритм функции должен сортировать список методом пузырьковой сортировки или методом сортировки выбором.
#6. Функция в итоге должна возвращать отсортированный список. Применить 1 раз данную функцию

'''1. Написать функцию binary_search, принимающую в качестве входящего параметра элемент для поиска и список
котором необходимо искать.
2. Алгоритм должен искать с помощью двоичного поиска, изображенного на блок-схеме презентации.
3. Функция в итоге должна распечатать результат. Применить 1 раз эту функцию'''

def binary_search(Val,list_of_num):
    N = len(list_of_num)
    Recult_Ok = False
    First = 0
    Last = N-1
    while First<Last:
        Middle = (First+Last)//2
        if Val==list_of_num[Middle]:
            First=Middle
            Last=First
            Recult_Ok=True
            Pos=Middle
        else:
            if Val>list_of_num[Middle]:
                First=Middle+1
            else:
                Last=Middle-1
    else:
        if Recult_Ok==True:
            print(f'Элемент найден: индекс элемента-{Pos}')
        else:
            print('Элемент не найден')

print(binary_search(6,[1, 2, 6, 8, 9, 10, 15, 48, 81, 200]))



'''Написать функцию buble_sort, принимающую в качестве входящего параметра не отсортированный список.
Алгоритм функции должен сортировать список методом пузырьковой сортировки.
Функция в итоге должна возвращать отсортированный список.'''
def bubble_sort(lst):
    length = len(lst)  # длина списка

    # Внешний цикл, без учета последнего элемента (т.к. туда всплывает большое)
    for i in range(length):

        # Внутренний цикл, за вычетом количества проверенных элементов:
        # если 3 эемент проверяется, то без учета этих трех, т.к. они уже заняли свои места в конце
        for j in range(0, length - i - 1):

            # Меняем элементы местами
            if lst[j] > lst[j + 1]:  # если предыдущий меньше, следующего:
                lst[j], lst[j + 1] = lst[j + 1], lst[j]  # меняет их местами
    return lst


print(bubble_sort([1, 8, 9, 10, 15, 6, 48, 200, 81, 2]))

'''Написать функцию selection_sort, принимающую в качестве входящего параметра не отсортированный список.
Алгоритм функции должен сортировать список методом сортировки выбором.
Функция в итоге должна возвращать отсортированный список.'''
def selection_sort(arr):
    for i in range(len(arr)):
        minimum = i  # 0,1,2,3,4,5,6,7,8,9

        for j in range(i + 1, len(arr)):
            # Выбор наименьшего значения
            if arr[j] < arr[minimum]:
                minimum = j

        # Помещаем это перед отсортированным концом массива
        arr[minimum], arr[i] = arr[i], arr[minimum]

    return arr


print(selection_sort([1200,15,200,99,1,5,6,88]))






